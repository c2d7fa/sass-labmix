////
/// @group math
///
/// This provides some common mathemetical functions implemented in pure Sass.
/// This module was implemented for an older version of Sass, that did not have
/// the `sass:math` module. This module may no longer be useful.
////

/// @type number

@use "sass:math";

$planifolia-math-steps-default: 32 !default;

/// @return {number}
@function pi() {
  @return math.$pi;
}

@function _pf-angle-to-rad($x) {
  @return math.div(0rad + $x, 1rad);
}

/// @param {number} $x
/// @return {number}
@function log($x, $steps: $planifolia-math-steps-default) {
  @if $x < 0 {
    @error 'cannot calculate log of #{$x}';
  }
  @return math.log($x);
}

/// @param {number} $x
/// @return {number}
@function log10($x, $steps: $planifolia-math-steps-default) {
  @if $x < 0 {
    @error 'cannot calculate log of #{$x}';
  }
  @return math.log($x, 10);
}

/// @param {number} $x
/// @param {number} $exponent
///   If $x is 0 or below, $exponent needs to be an integer.
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function pow($x, $exponent, $steps: $planifolia-math-steps-default) {
  @return math.pow($x, $exponent);
}

/// @param {number} $x
/// @param {number} $exponent
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function nth-root($x, $exponent, $steps: $planifolia-math-steps-default) {
  @return pow($x, math.div(1, $exponent), $steps);
}

/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function sqrt($x, $steps: $planifolia-math-steps-default) {
  @return nth-root($x, 2, $steps);
}

/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function sin($x, $steps: $planifolia-math-steps-default) {
  @return math.sin($x);
}

/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function cos($x, $steps: $planifolia-math-steps-default) {
  @return math.cos($x);
}

/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function tan($x, $steps: $planifolia-math-steps-default) {
  @return math.div(sin($x, $steps), cos($x, $steps));
}

/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function asin($x, $steps: $planifolia-math-steps-default) {
  @if $x < -1 or $x > 1 {
    @error 'cannot calculate asin(#{$x})';
  }
  @return _pf_angle_to_rad(math.asin($x));
}

/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function acos($x, $steps: $planifolia-math-steps-default) {
  @if $x < -1 or $x > 1 {
    @error 'cannot calculate acos(#{$x})';
  }
  @return _pf_angle_to_rad(math.acos($x));
}

/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function atan($x, $steps: $planifolia-math-steps-default) {
  @return _pf_angle_to_rad(math.atan($x));
}

/// Computes the angle of the vector (x,y) with the x axis.
/// @param {number} $y
/// @param {number} $x
/// @param {number} $steps [32] - steps of the taylor expansion
/// @return {number}
@function atan2($y, $x, $steps: $planifolia-math-steps-default) {
  @return _pf_angle_to_rad(math.atan2($y, $x));
}

@function _pf-interpolate($a, $b, $t) {
  $result: ();
  @for $i from 1 through length($a) {
    $value: nth($a, $i) * (1 - $t) + nth($b, $i) * $t;
    $result: append($result, $value);
  }
  @return $result;
}

/// Generic bezier interpolation.
/// @param {P[]} $points
/// @param {number} $t position 0 .. 1
/// @param {function(P, P, number) => P} $interpolate [_pf-interpolate]
///   The default is a linear interpolation between lists of numbers.
///   You can specify a custom interpolation function, e.g. to interpolate
///   between colors.
/// @return {P} A single point.
@function bezier($points, $t, $interpolate: get-function(_pf-interpolate)) {
  @if length($points) > 1 {
    $tmp: ();
    @for $i from 1 to length($points) {
      $point1: nth($points, $i);
      $point2: nth($points, $i + 1);
      $tmp: append($tmp, call($interpolate, $point1, $point2, $t));
    }
    @return bezier($tmp, $t, $interpolate);
  } @else {
    @return nth($points, 1);
  }
}
